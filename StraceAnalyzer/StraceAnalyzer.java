/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 Jesper Pedersen <jesper.pedersen@comcast.net>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software
 * is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.LineNumberReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;

/**
 * strace analyzer
 * @author <a href="jesper.pedersen@comcast.net">Jesper Pedersen</a>
 */
public class StraceAnalyzer
{
   /** Default configuration */
   private static final String DEFAULT_CONFIGURATION = "straceanalyzer.properties";

   /** The configuration */
   private static Properties configuration;

   /** Combine the resumed system calls */
   private static boolean combine = false;

   /** The file name */
   private static String filename;

   /** Data           Method  strace */
   private static Map<String, List<StraceEntry>> data = new TreeMap<>();
   
   /** Counts         Method  Count */
   private static Map<String, Integer> counts = new TreeMap<>();
   
   /**
    * Write data to a file
    * @param p The path of the file
    * @param l The data
    */
   private static void writeFile(Path p, List<String> l) throws Exception
   {
      BufferedWriter bw = Files.newBufferedWriter(p,
                                                  StandardOpenOption.CREATE,
                                                  StandardOpenOption.WRITE,
                                                  StandardOpenOption.TRUNCATE_EXISTING);
      for (String s : l)
      {
         bw.write(s, 0, s.length());
         bw.newLine();
      }

      bw.flush();
      bw.close();
   }

   /**
    * Write report
    */
   private static void writeReport() throws Exception
   {
      int total = 0;

      for (Integer i : counts.values())
      {
         total += i.intValue();
      }

      List<String> l = new ArrayList<>();

      l.add("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"");
      l.add("                      \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">");
      l.add("");
      l.add("<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">");
      l.add("<head>");
      l.add("  <title>strace Analysis: " + filename + "</title>");
      l.add("  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>");
      l.add("</head>");
      l.add("<body>");
      l.add("<h1>strace Analysis</h1>");
      l.add("");

      l.add("<table>");
      l.add("<tr>");
      l.add("<td><b>File</b></td>");
      l.add("<td>" + filename + "</td>");
      l.add("</tr>");
      l.add("<tr>");
      l.add("<td><b>Created</b></td>");
      l.add("<td>" + new Date() + "</td>");
      l.add("</tr>");
      l.add("</table>");
      l.add("<p>");

      l.add("<h2>Methods</h2>");
      l.add("<table>");

      for (Map.Entry<String, Integer> entry : counts.entrySet())
      {
         l.add("<tr>");
         l.add("<td><a href=\"" + entry.getKey() + ".html\">" + entry.getKey() + "</a></td>");
         l.add("<td>" + entry.getValue() + "</td>");
         l.add("</tr>");

         writeMethod(entry.getKey());
      }
      l.add("</table>");
      l.add("<p>");
      l.add("Total: " + total);
      
      l.add("<p>");
      l.add("Generated by <a href=\"https://github.com/jesperpedersen/postgres-tools/tree/master/StraceAnalyzer\">StraceAnalyzer</a>");

      l.add("</body>");
      l.add("</html>");

      writeFile(Paths.get("report", "index.html"), l);
   }

   /**
    * Write method report
    */
   private static void writeMethod(String method) throws Exception
   {
      List<String> l = new ArrayList<>();

      l.add("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"");
      l.add("                      \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">");
      l.add("");
      l.add("<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">");
      l.add("<head>");
      l.add("  <title>strace Analysis: " + method + "</title>");
      l.add("  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>");
      l.add("</head>");
      l.add("<body>");
      l.add("<h1>" + method +"</h1>");
      l.add("");

      List<StraceEntry> lse = data.get(method);

      l.add("<table>");
      for (StraceEntry se : lse)
      {
         l.add("<tr>");
         l.add("<td>" + se.getProcessId() + "</td>");
         l.add("<td>" + se.getTime() + "</td>");
         l.add("<td>" + se.getMethod() + (se.isInclude() ? "(" : "") + escapeChars(se.getArguments()) + (!"".equals(se.getReturnValue()) ? (") = " + escapeChars(se.getReturnValue())) : "") + "</td>");
         l.add("<td>" + (!se.isPartial() ? "" : "[*]") + "</td>");
         l.add("</tr>");
      }
      l.add("</table>");

      
      l.add("<p>");
      l.add("<a href=\"index.html\">Back</a>");
      l.add("</body>");
      l.add("</html>");

      writeFile(Paths.get("report", method + ".html"), l);
   }

   /**
    * Escape chars
    */
   private static String escapeChars(String input)
   {
      String s = input.replaceAll("<", "&lt;");
      s = s.replaceAll(">", "&gt;");
      return s;
   }

   /**
    * Process the log
    */
   private static void processLog() throws Exception
   {
      StraceEntry se = null;
      FileReader fr = null;
      LineNumberReader lnr = null;
      String s = null;
      try
      {
         fr = new FileReader(Paths.get(filename).toFile());
         lnr = new LineNumberReader(fr);
         s = lnr.readLine();

         while (s != null)
         {
            se = new StraceEntry(s);

            if (se.getMethod() != null)
            {
               List<StraceEntry> l = data.get(se.getMethod());
               if (l == null)
                  l = new ArrayList<>();
               l.add(se);
               data.put(se.getMethod(), l);

               Integer count = counts.get(se.getMethod());
               if (se.isInclude())
               {
                  if (count == null)
                  {
                     count = Integer.valueOf(1);
                  }
                  else
                  {
                     count = Integer.valueOf(count.intValue() + 1);
                  }
               }
               else
               {
                  count = Integer.valueOf(0);
               }
               counts.put(se.getMethod(), count);
            }
            else
            {
               if (combine && se.isPartial())
               {
                  int idx1 = se.getArguments().indexOf(" ");
                  int idx2 = se.getArguments().indexOf(" ", idx1 + 1);
                  int idx3 = se.getArguments().indexOf(">");

                  String processId = se.getProcessId();
                  String method = se.getArguments().substring(idx1 + 1, idx2);
                  String arguments = se.getArguments().substring(idx3 + 1).trim();
                  
                  List<StraceEntry> l = data.get(method);
                  for (int i = l.size() - 1; i >= 0; i--)
                  {
                     StraceEntry lse = l.get(i);
                     if (processId.equals(lse.getProcessId()))
                     {
                        String newArguments = lse.getArguments() + arguments;
                        lse.setArguments(newArguments);
                        lse.setReturnValue(se.getReturnValue());
                        break;
                     }
                  }
               }
            }

            s = lnr.readLine();
         }
      }
      catch (Exception e)
      {
         System.out.println("Error during:");
         System.out.println(s);
         throw e;
      }
      finally
      {
         if (lnr != null)
            lnr.close();

         if (fr != null)
            fr.close();
      }
   }

   /**
    * Read the configuration (replay.properties)
    * @param config The configuration
    */
   private static void readConfiguration(String config) throws Exception
   {
      File f = new File(config);
      configuration = new Properties();

      if (f.exists())
      {
         FileInputStream fis = null;
         try
         {
            fis = new FileInputStream(f);
            configuration.load(fis);
         }
         finally
         {
            if (fis != null)
            {
               try
               {
                  fis.close();
               }
               catch (Exception e)
               {
                  // Nothing todo
               }
            }
         }
      }
   }

   /**
    * Setup
    */
   private static void setup() throws Exception
   {
      File report = new File("report");
      if (report.exists())
      {
         Files.walk(Paths.get("report"))
            .sorted(Comparator.reverseOrder())
            .map(Path::toFile)
            .forEach(File::delete);
      }
      report.mkdir();
   }

   /**
    * Main
    * @param args The arguments
    */
   public static void main(String[] args)
   {
      try
      {
         if (args.length != 1)
         {
            System.out.println("Usage: StraceAnalyzer <file>");
            return;
         }

         readConfiguration(DEFAULT_CONFIGURATION);
         combine = Boolean.valueOf(configuration.getProperty("combine", "false"));
         setup();

         filename = args[0];
         processLog();
         writeReport();
      }
      catch (Exception e)
      {
         e.printStackTrace();
      }
   }

   /**
    * strace entry
    */
   static class StraceEntry
   {
      private String processId;
      private String time;
      private String method;
      private String args;
      private String returnValue;
      private boolean include;
      private boolean partial;
      
      StraceEntry(String s)
      {
         int idx3 = s.indexOf("(");

         if (idx3 != -1)
         {
            this.include = true;
            this.partial = false;
            
            String tmp = null;
            int idx1 = s.indexOf(" ");
            int offset = idx1;
            
            while (s.charAt(offset) == ' ')
               offset++;
            
            int idx2 = s.indexOf(" ", offset);
            int idx4 = s.indexOf("= ");

            this.processId = s.substring(0, idx1);
            this.time = s.substring(idx1 + 1, idx2).trim();
            this.method = s.substring(idx2 + 1, idx3);

            if (idx4 != -1)
            {
               if (s.charAt(idx2 + 1) != '<')
               {
                  // System calls that returns
                  tmp = s.substring(idx3 + 1, idx4).trim();

                  this.args = tmp.substring(0, tmp.length() - 1);
                  this.returnValue = s.substring(idx4 + 2);
               }
               else
               {
                  // Finished system calls
                  if (!combine)
                  {
                     this.method = "<";
                     this.args = s.substring(idx2 + 2);
                     this.returnValue = "";
                     this.include = false;
                     this.partial = true;
                  }
                  else
                  {
                     int p = s.indexOf(")", idx2 + 1);

                     // Mark as combine
                     this.method = null;
                     this.args = s.substring(idx2 + 1, p);
                     this.returnValue = s.substring(idx4 + 2);
                     this.include = false;
                     this.partial = true;
                  }
               }
            }
            else
            {
               // Unfinished system calls
               this.partial = true;
               if (!combine)
               {
                  this.args = s.substring(idx3 + 1);
               }
               else
               {
                  int to = s.indexOf("<unfinished");
                  if (to == -1)
                     to = s.indexOf("<detached");                  

                  this.args = s.substring(idx3 + 1, to - 1);
               }
               this.returnValue = "";
            }
         }
         else
         {
            this.include = false;
            this.partial = false;
            
            // Finished system calls
            int idx1 = s.indexOf(" ");
            int offset = idx1;
            
            while (s.charAt(offset) == ' ')
               offset++;
            
            int idx2 = s.indexOf(" ", offset);
            char c = s.charAt(idx2 + 1);
            
            if (c != '+' && c != '-')
            {
               this.partial = true;

               this.processId = s.substring(0, idx1);
               this.time = s.substring(idx1 + 1, idx2).trim();

               if (!combine)
               {
                  this.method = "<";
                  this.args = s.substring(idx2 + 2);
                  this.returnValue = "";
               }
               else
               {
                  int p = s.indexOf(")", idx2 + 1);
                  int idx4 = s.indexOf("= ", idx2 + 1);

                  // Mark as combine
                  this.method = null;
                  this.args = s.substring(idx2 + 1, p);
                  this.returnValue = s.substring(idx4 + 2);
               }
               this.include = false;
            }
         }
      }

      String getProcessId()
      {
         return processId;
      }

      String getTime()
      {
         return time;
      }

      String getMethod()
      {
         return method;
      }

      String getArguments()
      {
         return args;
      }

      void setArguments(String s)
      {
         args = s;
      }

      String getReturnValue()
      {
         return returnValue;
      }
      
      void setReturnValue(String s)
      {
         returnValue = s;
      }
      
      boolean isInclude()
      {
         return include;
      }
      
      boolean isPartial()
      {
         return partial;
      }
      
      @Override
      public String toString()
      {
         return processId + " " + time + " " + method + (include ? "(" : "") + args + (!"".equals(returnValue) ? ") = " + returnValue : "");
      }
   }
}
